initialize scale_estimate = 1
initialize vio_velocity_buffer = []
initialize imu_velocity_buffer = []

while p:
    vio_pose = fetch_vio_pose_world  # scale invariant
    imu_acc = fetch_imu_acc

    # Transform pose and acceleration to velocity
    vio_velocity = derivative_of_pose(vio_pose)
    imu_velocity = integrate_acceleration(imu_acc)
    transformed_imu_velocity = transform_to_world(scale_estimate * vio_pose, imu_velocity) 

    # Push the velocities to buffers
    vio_velocity_buffer.append(vio_velocity)
    imu_velocity_buffer.append(transformed_imu_velocity)

    # If buffers are full, remove the oldest element
    if len(vio_velocity_buffer) > BUFFER_SIZE:
        vio_velocity_buffer.pop(0)
        imu_velocity_buffer.pop(0)

    # Estimate new scale factor
    scale_estimate = least_squares_optimization(vio_velocity_buffer, imu_velocity_buffer)

    ## new 
    estimated_pose = EKF(vio_velocity*scale_estimate, transformed_imu_velocity)



    # Initialization: You need an initial estimate for the ekf_pose. This could be the first VIO pose, but it's scale invariant. A small error in the initial pose estimate could lead to large errors later on.

    # Causality: The EKF relies on the current IMU velocity and the scaled VIO pose. However, the scale factor is estimated based on past velocities. So you're using future information (the current velocities) to estimate the current pose, which can lead to a causality issue.

    # Accuracy of scale estimation: The scale factor is estimated based on velocities, and the velocities are noisy. If the noise is too large, the scale estimate could be inaccurate, leading to errors in the pose estimation.

    # Chicken-and-egg problem: As you noted, this approach has a chicken-and-egg problem. The scale factor depends on the velocities, and the velocities depend on the pose, which depends on the scale factor. If the initial scale factor is off, the errors could compound over time.



# This approach seems logically sound, but it also has potential issues:

#     Initial Convergence: You initialize your scale estimate to 1, but if the true scale is very different, it may take a long time for the algorithm to converge, if at all. The initial guess for the scale factor can dramatically affect the convergence of this iterative process.

#     Noise Sensitivity: Both IMU and VIO data are subject to noise. The scale estimation as you've implemented it can be highly sensitive to this noise, especially considering it's a direct division operation.

#     Numerical Stability: The division operation for the scale estimation can lead to numerical instability if the VIO pose is very close to zero.

#     Integration Errors: The pose from IMU is obtained by double integrating the acceleration data which is prone to drift and error over time. This error can propagate to your scale estimate.

#     Assumption of Matching Poses: The algorithm assumes that at every instance, the IMU pose and VIO pose correspond to the exact same physical pose. This might not be the case due to the different nature of these systems and any temporal calibration errors between them.

#     Lack of Formal Convergence Guarantee: This approach, as is, does not have a formal mathematical guarantee of convergence to the optimal scale factor.



# Certainly, here are some suggestions on how you might improve the loop to address the potential issues:

#     Initial Convergence: You could introduce a calibration phase where you estimate the initial scale factor from a known motion or a period of controlled movement. Alternatively, you could use a more advanced initialization method like expectation maximization.

#     Noise Sensitivity: To reduce noise sensitivity, consider using a filtering method to smooth out the IMU and VIO data. This could be a simple low-pass filter or a more complex filter like a Kalman filter or a particle filter.

#     Numerical Stability: For numerical stability, consider adding a small value to the denominator in the scale factor computation to avoid division by zero.

#     Integration Errors: Drift in the IMU integration could be mitigated by implementing sensor fusion techniques where the scale invariant VIO readings correct the drift in the IMU readings over time. In the long term, an IMU will drift, but in the short term, it can be more accurate than VIO, especially during fast movements. A common sensor fusion algorithm for this is the Extended Kalman Filter (EKF).

#    Assumption of Matching Poses: Implement some sort of synchronization or interpolation method to ensure that the IMU and VIO data you are comparing correspond to the same actual pose.

#   Lack of Formal Convergence Guarantee: You might want to formulate the scale estimation as an optimization problem (like least squares or maximum likelihood) that can provide a more robust estimate and a convergence guarantee. This will however require more computational resources.

#Running average for scale factor: Rather than directly updating the scale factor at each iteration, you can keep a running average of the scale factor. This can provide a more stable and reliable estimate as it won't fluctuate wildly due to anomalous readings.

#Remember, these are general suggestions and the best method(s) to use will depend on the specifics of your system, such as the noise characteristics of your sensors, the nature of the movements, and your computational resources. Also, as always with such systems, it is critical to thoroughly test any changes you make to ensure they improve performance in practice.


# Loop 1: Scale Estimation Loop
initialize scale_estimate = 1
initialize vio_velocity_buffer = []
initialize imu_velocity_buffer = []

while p:
    vio_pose = fetch_vio_pose_world  #scale invariant
    imu_acc = fetch_imu_acc

    #Transform pose and acceleration to velocity
    vio_velocity = derivative_of_pose(vio_pose)
    imu_velocity = integrate_acceleration(imu_acc)

    transformed_imu_velocity = transform_to_world(ekf_pose, imu_velocity) // Changed to ekf_pose

    # Push the velocities to buffers
    vio_velocity_buffer.append(vio_velocity)
    imu_velocity_buffer.append(transformed_imu_velocity)

    # If buffers are full, remove the oldest element
    if len(vio_velocity_buffer) > BUFFER_SIZE:
        vio_velocity_buffer.pop(0)
        imu_velocity_buffer.pop(0)

    # Estimate new scale factor
    scale_estimate = least_squares_optimization(vio_velocity_buffer, imu_velocity_buffer)


# Loop 2: EKF Estimation Loop
initialize ekf_pose

while True:
    # Fetch current IMU acceleration
    imu_acc = fetch_imu_acc
    
    # Transform acceleration to velocity
    imu_velocity = integrate_acceleration(imu_acc)
    transformed_imu_velocity = transform_to_world(ekf_pose, imu_velocity) # Changed to ekf_pose
    
    # Feed the current transformed IMU velocity and scaled VIO pose to the EKF
    ekf_pose = ekf_estimate(transformed_imu_velocity, scale_estimate * vio_pose)
